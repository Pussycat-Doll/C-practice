系统编程：
	(系统调用接口以及进程的认识)
	1.进程概念   ***
	2.进程控制   **
	3.基础IO     **
	4.进程间通信 **+
	5.进程信号   **
	6.多线程     ****
	
进程概念：
1.认识冯诺依曼体系结构
2.简单认识操作系统
3.进程概念
4.进程状态、优先级、环境变量、进程调度
5.程序地址空间

冯诺依曼体系结构：
					现代计算机硬件体系结构
				输入设备：键盘
				输出设备：显示器
				存储器：内存条
				运算器：中央处理器CPU
				控制器：
				
硬件结构，决定了软件行为。/所有的设备都是围绕存储器工作的。
操作系统：内核+应用
		功能：管理计算机硬件资源
		定位：搞管理的软件
		目的：让计算机更加好用

库函数与系统调用接口关系：库函数封装了系统调用接口；上下级的调用关系
进程是什么？
	浅层：运行中的程序。
	深层：站在操作系统的角度，进程就是一个运行中程序描述-PCB（进程控制块）
	LINUX下，PCB实际就是一个结构体：struct task_struct{...}
	进程如何描述一个运行中的程序：
		内存指针，程序计数器，上下文数据，标识符PID，进程状态，优先级，记账信息(一个进程在cpu上运行的时间)，io信息
		如何保持程序同时进行？
		cpu的分时机制-每个程序在cpu上运行都有一个时间片
		时间片：程序在CPU撒谎给你运行的这段时间，运行完毕则调度切换（人在视觉上，会觉得程序在同时进行）
		
		进程就是PCB
		
	如何查看进程：
	ps   -ef/-aux
	pid_t getpid(void) 获取调用进程的ID
	LINUX下的进程运行状态：
		运行态R(运行和就绪的)
		可中断休眠状态S
		不可中断休眠状态D(disk sleep)
		停止状态T
		死亡状态X(dead)   X_X
		追踪状态t(tracing stop)
		僵死状态(Zzombie)
		僵尸进程：处于僵死状态的进程
		僵尸进程的产生：
			子进程先于父进程退出，为了保存退出原因，因此资源并没有完全被释放
		因此子进程退出时，操作系统会通知父进程，让父进程获取子进程的退出原因,
		然后释放子进程的所有资源。如果父进程当前没有关注子进程退出状态，则子
		进程成为僵尸进程。
		僵尸进程的危害：资源泄露。
		僵尸进程的避免：进程等待。
		僵尸进程的处理：退出父进程。
		
		
	孤儿进程：父进程先于子进程退出，子进程成为孤儿进程，会被运行在后台，父进程成
			  为1号进程(init进程)（孤儿进程退出不会成为僵尸进程），查看用 ps -ef
			  
	守护进程(精灵进程)
			：特殊的孤儿进程。[在孤儿进程的基础上，脱离登陆会话]
			通常运行在后台，默默工作，不希望收到终端会话的影响。
		
	
	进程创建：pid_t fork(void)
			解释：creates  a  new  process  by duplicating the calling process.  The new process, 
			referred to as the child, is an exact duplicate of the calling process，referred to 
			as the parent(通过复制正在调用的进程来创建新进程。新进程称为子进程，正在调用的进程，称为父进程)
	
			  通过复制调用进程创建一个子进程，子进程因为拷贝了父进程PCB里面很多数据，因此子进程退出时，
			  操作系统会通知父进程，让父进程获取子进程的退出原因
			  与父进程内存指针以及程序计数器都相同，所以运行的代码以及运行的位置都一样
			  返回值：== -1 创建子进程失败
				      == 0 对于子进程，返回值是0
					  > 0 对于父进程，返回值是子进程的PID
	进程优先级：决定进程cpu资源的优先分配权  --PRI NI
				(数字越小，优先级越高)
	程序分类：cpu密集/io密集
	进程分类：批处理/交互式
			  renice -n 19 -p pid;     设置进程优先级(nice值的范围为-20 ~ 19)
			  
	环境变量：存放系统运行环境参数的变量。
			命令： env(查看系统中所有的环境变量)
				   echo(打印指定的变量)  --- echo $PATH
				   set(查看所有变量，包含环境变量在内)
				   export: 设置一个环境变量
				   unset:删除一个环境变量
			设置环境变量目的：
				1.让系统运行环境参数配置起来更加灵活
				2.环境变量具有全局特性
		代码操作：
				char* getenv(const char* name);
				
				
 #include<stdio.h>
 #include<stdlib.h>
 int main(int argc,char *argv[],char *env[])
 {
	extern char **environ;
    int i = 0;
	for(i = 0;environ[i] != NULL;++i)
    {
        printf("environ[%d] = %s\n",i,environ[i]);
    } 
    for(i = 0; i < argc; ++i)
    {
        printf("argv[%d] = %s\n",i,argv[i]);
    }
    for(i = 0;env[i] != NULL;++i)
    {
        printf("env[%d] = %s\n",i,env[i]);
    } 
      //char *getenv(const char *name);
      //通过环境变量名称获取内容
    char *ptr = getenv("MYTEST");
    if(ptr == NULL)
    {  
        printf("have no MYTEST\n");
        return -1;
    } 
    else
    {
        printf("MYTEST = %s\n",ptr);
    }
    return 0;
} 

程序地址空间：

	虚拟地址空间：是操作系统为进程所描述的一个假的地址空间；目的是为了让进程认为自己拥有一块
	连续的线性的完整的地址空间；但是实际上一个进程使用的内存并非连续存储，而是通过页表映射了
	虚拟地址与物理地址之间的关系；让进程通过页表获取物理地址，进而实现数据的离散式存储；
	
	作用：
	1.提高内存利用率<---物理的离散式存储
	2.保证了进程的独立性<---每个进程都只能访问自己的虚拟地址映射的物理内存
	3.页表可以进行内存访问控制<----页表可以对每个虚拟地址进行权限标记
	
	调研--MMU:进程内存管理			
				
				
创建一个子进程的流程：(写实拷贝技术)
1.创建pcb
2.拷贝父进程pcb中的数据(拥有相同的虚拟地址空间，相同的页表...)
3.父子进程一开始映射同一块物理地址内存
4.等到物理内存修改的时候才为子进程重新开辟内存，拷贝数据过来(要求进程的独立性)		

代码共享，数据独有：
	因为代码段是只读的，不会被修改，因此会一直映射同一块物理内存
	
一个虚拟地址的构成：页号 + 页内偏移

内存管理：
	分段式：对程序友好，但是内存利用率不高
	分页式：提高内存利用率
	段页式：目前采用的方案
	
物理地址计算方法：
虚拟地址/页面大小 = 页号
根据页号找到对应的块号
块号*块大小+页内偏移（虚拟地址
%页面大小）

	进程调度：操作系统通过调度pcb来实现调度程序在cpu上执行




















		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	